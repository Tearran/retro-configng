#!/bin/bash


#
# This script provides a Dialog box interface for managing Armbian configuration.
#


#
# The allowed commads to be run without root privileges not allowed with root privileges
declare -A user_commands
user_commands=( 
    ["--readme"]="Description for readme"
     ["--help"]="Description for help" 
     ["--join"]="Description for join" 
     ["--split"]="Description for split" 
     ["--example"]="Description for example" 
     ["--feature"]="Description for feature" 
     )

#
# check user_commands for non root options exit if root
#
if [[ $EUID != 0 && -z "${user_commands[$1]}" ]]; then
    echo "This requires root privileges. Try again with \"sudo \" please ..." >&2
    sleep 1
    exit 1
fi


#
# check for root privileges exit if non root options passed
#
if [[ $EUID == 0 && -n "${user_commands[$1]}" ]]; then
    echo "This Option requires normal privileges. Try again without sudo ..." >&2
    sleep 1
    exit 1
fi


#
# load functions, Dynamic directory root
#
bin="$(dirname "${BASH_SOURCE[0]}")"
directory="$(cd "$bin/../" && pwd )"
file_name="$(basename "${BASH_SOURCE[0]}")"
filename="${file_name%.*}"
json_file="$directory/etc/armbian-config/retro-config.json" || exit 1
json_data=$(cat "$json_file")
libpath="$directory/lib"


#
# load Armbian information
#
[[ -f "/etc/armbian-release" ]] && source /etc/armbian-release
[[ -f "/etc/os-release" ]] && source /etc/os-release


#
# Define the options for the loading modules    
#
declare -A module_options


#
# Function to Load the module files
#
source_modules() {
    local modpath="$1"
    for file in "$modpath"/*.sh
    do
        if [[ -f "$file" ]]; then
            source "$file" 
        fi
    done
} 


#
# If the file config.its.sh exists in the libpath directory, source it
#
if [[ -f "$libpath/config.its.sh" ]] ; then
    #This file is generated by the --join option
    source "$libpath/config.its.sh"
# If the file does not exist, but the directory config.split exists in the libpath directory, source all .sh files in it
elif [[ -d "$libpath/config.split" ]] ; then
    # This directory is generated by the --split option
    source_modules "$libpath/config.split"
# If neither the file config.its.sh nor the directory config.split exist, but the directory config.its exists in the libpath directory, source all .sh files in it
else
    # Include these scrits contains the dev module files
    source_modules "$libpath/config.its"
fi


#
# SET the TUI
#
[[ -x "$(command -v whiptail)" ]] && export DIALOG="whiptail"


#
# Function to Join the script modules into one file
#
join_scripts() {
    local modpath="$1"
    local output_file="$2"

    # Add a shebang and the declaration of the module_options associative array to the first lines of the output file
    echo -e "#!/bin/bash\n\tdeclare -A module_options" > "$output_file"

    for file in "$modpath"/*.sh
    do
        if [[ -f "$file" ]]; then
            # Add a marker
            echo "# Start of $(basename "$file")" >> "$output_file"

            # Remove the shebang from the file and add the contents to the output file
            sed '/^#!\/bin\/bash/d' "$file" >> "$output_file"
            
            # Add a newline
            echo "" >> "$output_file"
        fi
    done

    echo "    for key in \"\${!module_options[@]}\"; do" >> "$output_file"
    echo "        options[\"\$key\"]=\"\${module_options[\$key]}\"" >> "$output_file"
    echo "    done" >> "$output_file"
}


#
# Function to split the script into multiple Module files
#
split_script() {
    local input_file="$1"
    local output_dir="$2"
    mkdir -p "$output_dir"

    awk '
        BEGIN { RS = "\n# Start of"; FS = "\n"; OFS = "\n"; ORS = "\n"; }
        NR > 1 {
            sub(/ /, "", $1);
            output_file = sprintf("%s/%s", "'"$output_dir"'", $1);
            $1 = "#!/bin/bash";
            print $0 > output_file;
        }
    ' "$input_file"
}


#
# Function to generate the README.md file
#
generate_readme() {
    echo "Updating README.md."
    # Get the current date
    current_date=$(date)    

    cat << EOF > "$bin/../README.md"    
# Experiment: JSON Dialogue Box
This application is a command-line interface that interacts with a JSON file to perform various operations. It is open-source and licensed under the GPL.

The application reads a JSON file which contains a menu of commands. Each command in the menu has an associated ID and command string.

When the application starts, it generates a top-level menu from the JSON file. The user can select a command from the menu by entering the associated ID. If the user selects a command, the application executes the command.

Updated on $current_date.

$(generate_feature)


EOF
    # Print a message indicating that README.md has been updated
    echo "README.md has been updated."

}

#
# Function to generate the EXAMPLES.md file
#
generate_example() {
    echo "Updating EXAMPLES.md."
    # Get the current date
    current_date=$(date)    

    cat << EOF > "$bin/../EXAMPLES.md"
# Example: JSON Dialogue Box
This application is a command-line interface that interacts with a JSON file to perform various operations. It is open-source and licensed under the GPL.

$(parse_json)

EOF
    
        # Print a message indicating that README.md has been updated
        echo "EXAMPLES.md has been updated."
    }


#
# Function to generate the FEATURES.md file
#
generate_feature() {
    # Get the current date
    current_date=$(date)    

    cat << EOF 
# FEATURES: Table of Contents
$(see_use_readme)

EOF
    }


#
# Show Help mesaage
#
[[ $1 == "--help" || $1 == "-h" ]] && see_use && exit 0;
#
# Generate the EXAMPLES.md file from json
#
[[ $1 == "example" ]] && generate_example && exit 0;
#
# Generate the FEATURES.md file from array from the modules
#
[[ $1 == "feature" ]] && generate_feature && exit 0;
#
# Generate the README.md file
#
[[ "$1" == "--readme" ]] && generate_readme && exit 0;

#
# Join split the script modules into one file use --join folder/to/join file/to/join.sh
#
[[ "$1" == "--join" ]] && join_scripts  "$libpath/config.its" "$libpath/config.its.sh" && exit 0 ;
[[ "$1" == "--split" ]] && mkdir -p "$libpath/config.split" && split_script "$libpath/config.its.sh" "$libpath/config.split" && exit 0 ;

#
# Load the TUI
while true; do
    clear
    generate_top_menu || exit 1
done

exit 0

