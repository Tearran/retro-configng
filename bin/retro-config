#!/bin/bash

#
# Enable Dynamic directory root
# Simulate /usr/bin/ and /usr/lib/ directories 
bin="$(dirname "${BASH_SOURCE[0]}")"
directory="$(cd "$bin/../" && pwd )"
file_name="$(basename "${BASH_SOURCE[0]}")"
filename="${file_name%.*}"
# Set the path to the mod directory
modpath=$(cd "$directory/lib" && pwd)
suffix="${file_name##*-}"
# Armbian information
bin_dir="$(dirname "$(readlink -f "$BASH_SOURCE")")"
# Define the path to the JSON file
json_file="$directory/etc/armbian-config/retro-config.json"

function see_ping() {
    # List of servers to ping
    servers=("1.1.1.1" "8.8.8.8")

    # Check for internet connection
    for server in "${servers[@]}"; do
        if ping -q -c 1 -W 1 $server >/dev/null; then
            echo "  Checking for Network "
            echo "     Internet connection is present."
            echo ""
            return
        else
            echo -e "\e[5;31mWARNING: Internet Not available.\e[0m"
            echo "  Checking for Network - times."
            echo "    This app has been disabled? eixt"
            echo ""
            exit 1
        fi
    done
}

function is_apt_list_current() {
    # Number of seconds in a day
    local day=86400

    # Get the current date as a Unix timestamp
    local now=$(date +%s)

    # Get the last start time of apt-daily.service as a Unix timestamp
    local update=$(date -d "$(systemctl show -p ActiveEnterTimestamp apt-daily.service | cut -d'=' -f2)" +%s)

    # Calculate the number of seconds since the last update
    local elapsed=$(( now - update ))

    # Check if the package list is up-to-date
    if (( elapsed < day )); then
        echo "  Checking for apt-daily.service"
        echo "    The package lists are up-to-date."
        echo ""
        return 0  # The package lists are up-to-date
    else
        echo "  Checking for apt-daily.service"
        echo "    The package lists are not up-to-date."
        echo ""
        return 1  # The package lists are not up-to-date
    fi
}

if command -v whiptail &> /dev/null
then
    dialog_cmd="whiptail"
elif command -v dialog &> /dev/null
then
    dialog_cmd="dialog"
else
    cat << EOF
Error: Neither 'dialog' nor 'whiptail' is installed.
Please install whiptail for best of them and try again.

EOF

	exit 1
fi

############################
# colors
############################    
set_colors() {
    local color_code=$1

    if [ "$dialog_cmd" = "whiptail" ]; then
        set_newt_colors $color_code
    elif [ "$dialog_cmd" = "dialog" ]; then
        set_term_colors $color_code
    else
        echo "Invalid dialog type"
        return 1
    fi
}

set_newt_colors() {
    local color_code=$1
    case $color_code in
        0) color="black" ;;
        1) color="red" ;;
        2) color="green" ;;
        3) color="yellow" ;;
        4) color="blue" ;;
        5) color="magenta" ;;
        6) color="cyan" ;;
        7) color="white" ;;
        *) echo "Invalid color code"; return 1 ;;
    esac
    export NEWT_COLORS="root=,$color"
}

set_term_colors() {
    local color_code=$1
    case $color_code in
        0) color="\e[40m" ;;  # black
        1) color="\e[41m" ;;  # red
        2) color="\e[42m" ;;  # green
        3) color="\e[43m" ;;  # yellow
        4) color="\e[44m" ;;  # blue
        5) color="\e[45m" ;;  # magenta
        6) color="\e[46m" ;;  # cyan
        7) color="\e[47m" ;;  # white
        *) echo "Invalid color code"; return 1 ;;
    esac
    echo -e "$color"
}

reset_colors() {
    echo -e "\e[0m"
}

#############################
trap reset_colors EXIT
#############################

# display a dialog box with pipe 'echo -e "test" | display_dialog'
# display a dialog box with "$1" 'display_dialog "test"'
display_dialog() {
    local input
    if [ -p /dev/stdin ]; then
        input=$(cat)
    else
        input="$1"
    fi
    $dialog_cmd --title "Script Completed" --msgbox "$input " 0 78
}

display_infobox() {
    export TERM=ansi
    local input
    local BACKTITLE="Processing"
    local -a buffer  # Declare buffer as an array
    if [ -p /dev/stdin ]; then
        while IFS= read -r line; do
            buffer+=("$line")  # Add the line to the buffer
            # If the buffer has more than 10 lines, remove the oldest line
            if (( ${#buffer[@]} > 10 )); then
                buffer=("${buffer[@]:1}")
            fi
            # Display the lines in the buffer in the infobox

            TERM=ansi $dialog_cmd --title "$BACKTITLE" --infobox "$(printf "%s\n" "${buffer[@]}" )" 16 80
            sleep 0.5
        done
    else
        
        input="$1"
        TERM=ansi $dialog_cmd --title "$BACKTITLE" --infobox "$( echo "$input" )" 8 80
    fi
        echo -ne '\033[3J' # clear the screen
}

display_yesno() {
    local title="Continue"
    local message="$1"
    local height="8"
    local width="80"
    if "$dialog_cmd" --title "$title" --yesno "$message " 8 80 ; then
        echo "User selected Yes, exit status was $?."
    else
        echo "User selected No, exit status was $?."
        exit 0
    fi
}

display_inputbox() {

    local prompt="$2"
    local default_value=""
    local height="8"
    local width="39"
    local input=$(whiptail --inputbox "$prompt" "$height" "$width" "$default_value" --title "$title" 3>&1 1>&2 2>&3)
    local exitstatus=$?
    if [ $exitstatus = 0 ]; then
        echo "User selected Ok and entered " $input
    else
        echo "User selected Cancel."
    fi
    echo "(Exit status was $exitstatus)"
}

execute_command() {
    local id=$1
    local param=$2
    [[ "$id" == "" ]] && exit 0
    local command=$(jq -r --arg id "$id" '.menu[] | .. | objects | select(.id==$id) | .command' $json_file)
    local requirements=$(jq -r --arg id "$id" '.menu[] | .. | objects | select(.id==$id) | .requirements | .[] | split(" ") | .[]' $json_file)
    command=${command:-null}
    if [ "$command" != "null" ]; then
        echo "Preparing to execute command associated with ID '$id'..."
        IFS=' ' read -r -a requirements_array <<< "$requirements"
        if [ ${#requirements_array[@]} -ne 0 ]; then
            echo "Checking and installing dependencies for command..."
            see_get_dependencies "${requirements_array[@]}"
            if [ $? -ne 0 ]; then
                echo "Error: Requirements: [$requirements] for command associated with ID '$id' are not met"
                exit 1
            fi
        fi
        echo "Executing command..."
        (eval "$command $param" ) &
        local command_pid=$!
        wait $command_pid
        echo "Command executed successfully."
        return 0
    else
        echo "Error: No command associated with ID '$id'"
        exit 1
    fi 
}

see_get_dependencies() {
    for dep in "$@"; do
        echo "Checking for dependency: $dep"
        if ! command -v $dep &> /dev/null; then
            echo "$dep could not be found, attempting to install..."
            sudo apt-get install -y $dep
            if [ $? -ne 0 ]; then
                echo "Failed to install $dep. Please install it manually."
                return 1
            fi
        fi
        echo "$dep is installed."
    done
    echo "All dependencies are installed."
    return 0
}
see_remove_dependencies() {
    for dep in "$@"; do
        echo "Checking for dependency: $dep"
        if command -v $dep &> /dev/null; then
            echo "$dep found, attempting to remove..."
            sudo apt-get purge -y $dep
            if [ $? -ne 0 ]; then
                echo "Failed to remove $dep. Please remove it manually."
                return 1
            fi
        else
            echo "$dep is not installed."
        fi
    done
    echo "All specified dependencies are removed."
    return 0
}
###################################################################

# generate a menu for a given parent_id
generate_menu() {
    local parent_id=$1

    # Get the submenu options for the current parent_id
    local submenu_options=()
    while IFS= read -r id
    do
        IFS= read -r description
        local requirements=$(jq -r --arg id "$id" '.menu[] | .. | objects | select(.id==$id) | .requirements[]?' $json_file)
        if see_get_dependencies $requirements; then
            submenu_options+=("$id" "$description")
        fi
    done < <(jq -r --arg parent_id "$parent_id" '.menu[] | .. | objects | select(.id==$parent_id) | .sub[]? | select(.show==true) | "\(.id)\n\(.description)"' $json_file)
    set_colors 2 # "$?"
    
    local OPTION=$($dialog_cmd --title "Menu" --menu "Choose an option" 0 80 9 "${submenu_options[@]}" \
                            --ok-button Select --cancel-button Back 3>&1 1>&2 2>&3)

    local exitstatus=$?

    if [ $exitstatus = 0 ]; then
        if [ "$OPTION" == "" ]; then
            generate_top_menu
        fi
        # Check if the selected option has a submenu
        local submenu_count=$(jq -r --arg id "$OPTION" '.menu[] | .. | objects | select(.id==$id) | .sub[]? | length' $json_file)
        submenu_count=${submenu_count:-0}  # If submenu_count is null or empty, set it to 0
        if [ $submenu_count -gt 0 ]; then
            # If it does, generate a new menu for the submenu
            set_colors 2 # "$?"
            generate_menu "$OPTION"
        else
            # If it doesn't, execute the command
            execute_command "$OPTION"
        fi
    fi

    }

# generate the top-level menu
generate_top_menu() {
    #clear
    # Get the top-level menu options
    color_option="green"
    local menu_options=()
    while IFS= read -r id
    do
        IFS= read -r description
        menu_options+=("$id" "$description")
    done < <(jq -r '.menu[] | "\(.id)\n\(.description)"' $json_file)

    set_colors 4 # "$?"

    # Generate the $dialog_cmd menu
    local OPTION=$($dialog_cmd --title "Menu" --menu "Choose an option" 0 80 9 "${menu_options[@]}" 3>&1 1>&2 2>&3)
    local exitstatus=$?

    if [ $exitstatus = 0 ]; then
        if [ "$OPTION" == "" ]; then
            exit 0
        fi    
        generate_menu "$OPTION"
    fi
}

# Serve array editor
serve_debug() {
    if [[ "$(id -u)" == "0" ]] ; then
		echo "Yello World!"
		exit 1
	fi
    cd $bin_dir && local html_file="index.html"
    if [[ -z $CODESPACES ]]; then
        if command -v python3 &> /dev/null
        then
            # Start the Python server in the background
            python3 -m http.server > /tmp/$USER.config.log 2>&1 &
            local server_pid=$!

            # Get the IP address of the server
            local server_ip=$(hostname -I | cut -d' ' -f1)

            {
                echo " Simple server started"
                echo -e  "\n  pid $server_pid"
                echo -e  "\n  Server URL: http://$server_ip:8000"
                echo -e  "\n  Press enter to stop server and exit"
            } 

            # Stop the server
            kill $server_pid
            exit 0
        fi
    else
        echo "GitHub Codespace"
        exit 0
    fi
}
sudoer_error() {
 set_newt_colors 1
 echo "This tool requires root privileges. Please try: sudo ${0##*/} " | display_infobox
 exit 1
}

user_error() {
 set_newt_colors 3
 echo "Develoment tool 'user privileges' only. Please try: ${0##*/} " | display_infobox
 exit 1
}

display_help() {
        cat << EOF

Usage: [standard output] | ${0##*/} [option]

  -h, --help       Show this help message
  -q, --yesno      Yes No Question
  -s, --server     start a local server debug and edit
  -o, --message    Show a OK message box
  -p, --popup      Use a progress popup
      --deps       Install missing dependencies
      --purge      Remove installed
      --ping       Check connection with fallback DNS

        If no option is provided, the menu will be shown.

    Environment Variables:
         dialog boxes, \$DIALOG currently set to: $DIALOG

    Example try:
        echo "hello" | ${0##*/} -o
        ${0##*/} --deps git nano
        ${0##*/} --ping

EOF
}

case "$1" in
    "-h" | "--help")
		display_help
		exit 0
	;;
    "-s" | "--server")
        # Exit fail if user is root 
    	if [[ "$(id -u)" == "0" ]] ; then
			user_error
			exit 1
		else
    		set_newt_colors 3
			serve_debug | display_dialog
        	exit 0
		fi
		;;
    "-o" | "--message")
		display_dialog
		;;
    "-p" | "--popup")
		display_infobox
		;;
	"-P" | "--ping")
        see_ping
		exit 0
		;;
	"-D" | "--deps")
        # Exit fail if user is not root
        [[ $(id -u) -ne 0 ]] && sudoer_error
        see_ping
        is_apt_list_current
        shift
        see_get_dependencies "${@}"
		exit 0
	;;
	"-R" | "--purge")
        see_ping
        [[ $(id -u) -ne 0 ]] && sudoer_error
        is_apt_list_current | display_infobox
        shift
        see_remove_dependencies "${@}" | display_infobox
		;;
	"-U" | "--Update")
        [[ $(id -u) -ne 0 ]] && sudoer_error
        is_apt_list_current ;;
#     *) echo "Invalid option: $1" ; display_help ;;
esac

    [[ $(id -u) -ne 0 ]] && sudoer_error
    [[ "$(id -u)" == "0" ]] && generate_top_menu

