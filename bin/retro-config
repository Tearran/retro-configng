#!/bin/bash


#
# This script provides a Dialog box interface for managing Armbian configuration.
#


#
# check for root privileges if not check for non root options
#
allowed_commands=("--readme" "--help" "--join" "--split")

if [[ $EUID != 0 && ! " ${allowed_commands[@]} " =~ " $1 " ]]; then
    echo "This tool requires root privileges. Try again with \"sudo \" please ..." >&2
    sleep 1
    exit 1
fi

if [[ $EUID == 0 && " ${allowed_commands[@]} " =~ " $1 " ]]; then
    echo "This tool requires normal privileges. Try again without sudo ..." >&2
    sleep 1
    exit 1
fi

#
# load functions, Dynamic directory root
#
bin="$(dirname "${BASH_SOURCE[0]}")"
directory="$(cd "$bin/../" && pwd )"
file_name="$(basename "${BASH_SOURCE[0]}")"
filename="${file_name%.*}"
# Set the path to the mod directory
modpath=$(cd "$directory/lib" && pwd)
json_file="$directory/etc/armbian-config/retro-config.json" || exit 1
json_data=$(cat "$json_file")
libpath="$directory/lib"


#
# load Armbian information
#
[[ -f "/etc/armbian-release" ]] && source /etc/armbian-release
[[ -f "/etc/os-release" ]] && source /etc/os-release

# Define the options for the module    
declare -A module_options

# Load the module files
source_modules() {
    local modpath="$1"
    for file in "$modpath"/*.sh
    do
        if [[ -f "$file" ]]; then
            source "$file" 
        fi
    done
} 

if [[ -f "$libpath/config.its.sh" ]] ; then
    source "$libpath/config.its.sh"
elif [[ -d "$libpath/config.split" ]] ; then
    source_modules "$libpath/config.split"
else
    source_modules "$libpath/config.its"
fi

#
# SET the TUI
#
[[ -x "$(command -v whiptail)" ]] && export DIALOG="whiptail"

join_scripts() {
    local modpath="$1"
    local output_file="$2"

    # Add a shebang and the declaration of the module_options associative array to the first lines of the output file
    echo -e "#!/bin/bash\n\tdeclare -A module_options" > "$output_file"

    for file in "$modpath"/*.sh
    do
        if [[ -f "$file" ]]; then
            # Add a marker
            echo "# Start of $(basename "$file")" >> "$output_file"

            # Remove the shebang from the file and add the contents to the output file
            sed '/^#!\/bin\/bash/d' "$file" >> "$output_file"
            
            # Add a newline
            echo "" >> "$output_file"
        fi
    done

    echo "    for key in \"\${!module_options[@]}\"; do" >> "$output_file"
    echo "        options[\"\$key\"]=\"\${module_options[\$key]}\"" >> "$output_file"
    echo "    done" >> "$output_file"
}

split_script() {
    local input_file="$1"
    local output_dir="$2"
    mkdir -p "$output_dir"

    awk '
        BEGIN { RS = "\n# Start of"; FS = "\n"; OFS = "\n"; ORS = "\n"; }
        NR > 1 {
            sub(/ /, "", $1);
            output_file = sprintf("%s/%s", "'"$output_dir"'", $1);
            $1 = "#!/bin/bash";
            print $0 > output_file;
        }
    ' "$input_file"
}


#
# Show Help mesaage
#
[[ $1 == "--help" || $1 == "-u" ]] && see_use && exit 0;

[[ "$1" == "--readme" ]] && see_use > "$bin/../README.md" && parse_json >> "$bin/../README.md" echo "README.md has been updated." && exit 0;

[[ "$1" == "--join" ]] && join_scripts  "$libpath/config.its" "$libpath/config.its.sh" && exit 0 ;

[[ "$1" == "--split" ]] && mkdir -p "$libpath/config.split" && split_script "$libpath/config.its.sh" "$libpath/config.split" && exit 0 ;

#
# Load the TUI
while true; do
    #clear
    generate_top_menu || exit 1
done

exit 0

